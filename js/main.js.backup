// ===================================
// NEFEX Website - Main JavaScript
// Intelligence Engineered
// ===================================

// ===== Mobile Menu Toggle =====
const menuToggle = document.getElementById('menuToggle');
const navLinks = document.getElementById('navLinks');

if (menuToggle) {
  menuToggle.addEventListener('click', () => {
    menuToggle.classList.toggle('active');
    navLinks.classList.toggle('active');
  });

  // Close menu when clicking on a link
  navLinks.querySelectorAll('a').forEach(link => {
    link.addEventListener('click', () => {
      menuToggle.classList.remove('active');
      navLinks.classList.remove('active');
    });
  });
}

// ===== Header Scroll Effect & Hero Stage Animation =====
const header = document.getElementById('header');
const scrollIndicator = document.getElementById('scrollIndicator');
const hero = document.getElementById('hero');
let lastScroll = 0;

window.addEventListener('scroll', () => {
  const currentScroll = window.pageYOffset;

  // Header scroll effect
  if (currentScroll > 100) {
    header.classList.add('scrolled');
  } else {
    header.classList.remove('scrolled');
  }

  // Apple-style Hero Stage Animation
  if (hero) {
    const heroHeight = hero.offsetHeight;
    const heroScrolled = currentScroll;
    const scrollPercent = heroScrolled / heroHeight;

    const stages = document.querySelectorAll('.hero-stage');
    stages.forEach(stage => {
      const scrollStart = parseFloat(stage.dataset.scrollStart);
      const scrollEnd = parseFloat(stage.dataset.scrollEnd);

      if (scrollPercent >= scrollStart && scrollPercent < scrollEnd) {
        stage.classList.add('active');
      } else {
        stage.classList.remove('active');
      }
    });

    // Hide scroll indicator
    if (scrollIndicator && currentScroll > 100) {
      scrollIndicator.classList.add('hidden');
    } else if (scrollIndicator) {
      scrollIndicator.classList.remove('hidden');
    }
  }

  lastScroll = currentScroll;
});

// ===== Smooth Scroll =====
document.querySelectorAll('a[href^="#"]').forEach(anchor => {
  anchor.addEventListener('click', function (e) {
    const href = this.getAttribute('href');
    if (href !== '#') {
      e.preventDefault();
      const target = document.querySelector(href);
      if (target) {
        const headerHeight = header.offsetHeight;
        const targetPosition = target.offsetTop - headerHeight;

        window.scrollTo({
          top: targetPosition,
          behavior: 'smooth'
        });
      }
    }
  });
});

// ===== Intersection Observer for Fade-in Animations =====
const observerOptions = {
  threshold: 0.1,
  rootMargin: '0px 0px -50px 0px'
};

const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      entry.target.classList.add('visible');
    }
  });
}, observerOptions);

// Observe all cards and sections
document.querySelectorAll('.card, .section').forEach(el => {
  el.classList.add('fade-in');
  observer.observe(el);
});

// ===== Counter Animation =====
const counters = document.querySelectorAll('.counter');

const animateCounter = (counter) => {
  const target = parseInt(counter.getAttribute('data-target'));
  const increment = target / 100;
  let current = 0;

  const updateCounter = () => {
    current += increment;
    if (current < target) {
      counter.textContent = Math.ceil(current) + (counter.textContent.includes('%') ? '%' : '+');
      requestAnimationFrame(updateCounter);
    } else {
      counter.textContent = target + (counter.textContent.includes('%') ? '%' : '+');
    }
  };

  updateCounter();
};

const counterObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      animateCounter(entry.target);
      counterObserver.unobserve(entry.target);
    }
  });
}, { threshold: 0.5 });

counters.forEach(counter => counterObserver.observe(counter));

// ===================================
// 3D BRAIN VISUALIZATION WITH THREE.JS
// ===================================

let scene, camera, renderer, brain, particles, dataElements;
let mouseX = 0, mouseY = 0;
let scrollProgress = 0;

function init3DBrain() {
  const canvas = document.getElementById('brain-canvas');
  if (!canvas || typeof THREE === 'undefined') {
    console.log('Three.js not loaded or canvas not found');
    return;
  }

  // Scene setup
  scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x070d15, 10, 50);

  // Camera setup
  camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  camera.position.z = 15;

  // Renderer setup
  renderer = new THREE.WebGLRenderer({
    canvas: canvas,
    alpha: true,
    antialias: true
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);

  // ===== BRAIN STRUCTURE =====
  const brainGroup = new THREE.Group();

  // Create brain hemispheres
  const createBrainHemisphere = (xOffset) => {
    const hemisphere = new THREE.Group();

    const lobeGeometry = new THREE.SphereGeometry(2, 32, 32, 0, Math.PI);
    const lobeMaterial = new THREE.MeshPhongMaterial({
      color: 0x0066ff,
      wireframe: true,
      transparent: true,
      opacity: 0.4,
      emissive: 0x00d4ff,
      emissiveIntensity: 0.3
    });
    const lobe = new THREE.Mesh(lobeGeometry, lobeMaterial);
    lobe.rotation.y = xOffset > 0 ? -Math.PI / 2 : Math.PI / 2;
    hemisphere.add(lobe);

    for (let i = 0; i < 5; i++) {
      const bumpGeometry = new THREE.SphereGeometry(0.4, 16, 16);
      const bump = new THREE.Mesh(bumpGeometry, lobeMaterial);
      bump.position.set(
        xOffset + (Math.random() - 0.5) * 1.5,
        (Math.random() - 0.5) * 2,
        (Math.random() - 0.5) * 1.5
      );
      hemisphere.add(bump);
    }

    hemisphere.position.x = xOffset;
    return hemisphere;
  };

  brainGroup.add(createBrainHemisphere(-0.8));
  brainGroup.add(createBrainHemisphere(0.8));

  // Corpus callosum
  const corpusGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.6, 16);
  const corpusMaterial = new THREE.MeshPhongMaterial({
    color: 0x00d4ff,
    transparent: true,
    opacity: 0.6,
    emissive: 0x0066ff,
    emissiveIntensity: 0.4
  });
  const corpus = new THREE.Mesh(corpusGeometry, corpusMaterial);
  corpus.rotation.z = Math.PI / 2;
  brainGroup.add(corpus);

  // Neural pathways
  const pathwayMaterial = new THREE.LineBasicMaterial({
    color: 0x00d4ff,
    transparent: true,
    opacity: 0.5
  });

  for (let i = 0; i < 20; i++) {
    const points = [];
    const startX = (Math.random() - 0.5) * 4;
    const startY = (Math.random() - 0.5) * 4;
    const startZ = (Math.random() - 0.5) * 4;

    points.push(new THREE.Vector3(startX, startY, startZ));
    points.push(new THREE.Vector3(
      startX + (Math.random() - 0.5) * 2,
      startY + (Math.random() - 0.5) * 2,
      startZ + (Math.random() - 0.5) * 2
    ));

    const pathwayGeometry = new THREE.BufferGeometry().setFromPoints(points);
    const pathway = new THREE.Line(pathwayGeometry, pathwayMaterial);
    brainGroup.add(pathway);
  }

  brain = brainGroup;

  // ===== NEURON PARTICLES =====
  const particleCount = 500;
  const particlesGeometry = new THREE.BufferGeometry();
  const particlePositions = new Float32Array(particleCount * 3);

  for (let i = 0; i < particleCount; i++) {
    const radius = 3 + Math.random() * 2;
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.random() * Math.PI;

    particlePositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
    particlePositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
    particlePositions[i * 3 + 2] = radius * Math.cos(phi);
  }

  particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));

  const particlesMaterial = new THREE.PointsMaterial({
    color: 0x00d4ff,
    size: 0.1,
    transparent: true,
    opacity: 0.8,
    blending: THREE.AdditiveBlending
  });

  particles = new THREE.Points(particlesGeometry, particlesMaterial);
  brainGroup.add(particles);

  // ===== DATA ELEMENTS =====
  dataElements = new THREE.Group();

  const createDataCard = (x, y, z, color) => {
    const cardGeometry = new THREE.PlaneGeometry(1.5, 1);
    const cardMaterial = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 0,
      side: THREE.DoubleSide
    });
    const card = new THREE.Mesh(cardGeometry, cardMaterial);
    card.position.set(x, y, z);
    return card;
  };

  const dataCards = [
    createDataCard(-5, 2, 0, 0x0066ff),
    createDataCard(5, 2, 0, 0x00d4ff),
    createDataCard(-5, -2, 0, 0x6b4ce6),
    createDataCard(5, -2, 0, 0x0066ff),
  ];

  dataCards.forEach(card => dataElements.add(card));
  brainGroup.add(dataElements);

  scene.add(brainGroup);

  // ===== LIGHTING =====
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);

  const pointLight1 = new THREE.PointLight(0x00d4ff, 1, 100);
  pointLight1.position.set(10, 10, 10);
  scene.add(pointLight1);

  const pointLight2 = new THREE.PointLight(0x0066ff, 1, 100);
  pointLight2.position.set(-10, -10, -10);
  scene.add(pointLight2);

  // ===== EVENTS =====
  document.addEventListener('mousemove', (event) => {
    mouseX = (event.clientX / window.innerWidth) * 2 - 1;
    mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
  });

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Start animation
  animate();
}

// ===== ANIMATION LOOP =====
function animate() {
  requestAnimationFrame(animate);

  if (!brain || !particles) return;

  // Rotate brain
  brain.rotation.y += 0.002;
  brain.rotation.x += 0.001;

  // Mouse parallax
  brain.rotation.y += mouseX * 0.001;
  brain.rotation.x += mouseY * 0.001;

  // Animate particles
  const positions = particles.geometry.attributes.position.array;
  for (let i = 0; i < positions.length; i += 3) {
    positions[i] += Math.sin(Date.now() * 0.001 + i) * 0.01;
    positions[i + 1] += Math.cos(Date.now() * 0.001 + i) * 0.01;
  }
  particles.geometry.attributes.position.needsUpdate = true;

  // Scroll-based transformations
  const heroEl = document.getElementById('hero');
  if (heroEl) {
    const heroHeight = heroEl.offsetHeight;
    const scrolled = window.pageYOffset;
    scrollProgress = Math.min(scrolled / heroHeight, 1);

    // Zoom effect
    camera.position.z = 15 - (scrollProgress * 10);

    // Brain scale
    brain.scale.set(
      1 + scrollProgress * 0.5,
      1 + scrollProgress * 0.5,
      1 + scrollProgress * 0.5
    );

    // Data elements visibility
    dataElements.children.forEach((card, index) => {
      card.material.opacity = scrollProgress;
      card.rotation.z = scrollProgress * Math.PI * 2;

      const angle = (index / dataElements.children.length) * Math.PI * 2;
      const distance = scrollProgress * 3;
      card.position.x = Math.cos(angle) * distance * 3;
      card.position.y = Math.sin(angle) * distance * 3;
    });
  }

  renderer.render(scene, camera);
}

// ===== INITIALIZE ON LOAD =====
window.addEventListener('load', () => {
  init3DBrain();
});

if (document.readyState === 'complete') {
  init3DBrain();
}
