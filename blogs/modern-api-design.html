<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description"
        content="Modern API Design Patterns - The Architect's Guide to REST, GraphQL, gRPC, Event-Driven APIs, and multi-paradigm API strategy.">
    <meta name="keywords"
        content="API Design, REST, GraphQL, gRPC, Event-Driven APIs, Microservices, API Gateway, OpenAPI, AsyncAPI">
    <title>Modern API Design Patterns | NEFEX Technologies</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Space+Grotesk:wght@400;500;600;700&display=swap"
        rel="stylesheet">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <!-- Styles -->
    <link rel="stylesheet" href="../css/style.css">

    <style>
        .blog-post-container {
            max-width: 900px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .blog-header {
            margin-bottom: 48px;
            text-align: center;
        }

        .blog-meta {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        .blog-category {
            background: rgba(59, 130, 246, 0.1);
            color: #60A5FA;
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .blog-date {
            color: var(--text-gray);
            font-size: 0.95rem;
        }

        .blog-title {
            font-size: 2.5rem;
            font-weight: 800;
            color: var(--text-white);
            margin-bottom: 20px;
            line-height: 1.2;
        }

        .blog-excerpt {
            font-size: 1.2rem;
            color: var(--text-gray);
            line-height: 1.6;
        }

        /* Podcast Player */
        .podcast-player {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 32px;
            margin-bottom: 48px;
        }

        .podcast-title {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            color: #60A5FA;
            font-weight: 600;
            font-size: 1.1rem;
        }

        audio {
            width: 100%;
            outline: none;
        }

        /* Blog Content */
        .blog-content {
            color: var(--text-light);
            line-height: 1.8;
            font-size: 1.05rem;
        }

        .blog-content h2 {
            color: var(--text-white);
            font-size: 1.8rem;
            font-weight: 700;
            margin-top: 56px;
            margin-bottom: 24px;
            padding-top: 24px;
            border-top: 2px solid rgba(96, 165, 250, 0.2);
        }

        .blog-content h3 {
            color: #60A5FA;
            font-size: 1.3rem;
            font-weight: 600;
            margin-top: 32px;
            margin-bottom: 16px;
        }

        .blog-content p {
            margin-bottom: 24px;
        }

        .blog-content ul,
        .blog-content ol {
            margin-bottom: 24px;
            padding-left: 32px;
        }

        .blog-content li {
            margin-bottom: 12px;
        }

        .blog-content strong {
            color: var(--text-white);
            font-weight: 600;
        }

        .blog-image {
            margin: 48px 0;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(96, 165, 250, 0.1);
        }

        .blog-image img {
            width: 100%;
            height: auto;
            display: block;
        }

        .blog-image-caption {
            text-align: center;
            color: var(--text-gray);
            font-size: 0.9rem;
            margin-top: 12px;
            font-style: italic;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 32px 0;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
            overflow: hidden;
        }

        .comparison-table th {
            background: rgba(96, 165, 250, 0.1);
            color: var(--text-white);
            padding: 16px;
            text-align: left;
            font-weight: 600;
        }

        .comparison-table td {
            padding: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-light);
        }

        .back-to-blogs {
            text-align: center;
            margin-top: 64px;
            padding-top: 48px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        @media (max-width: 768px) {
            .blog-title {
                font-size: 1.8rem;
            }

            .blog-content h2 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>

<body style="background: #0A0E27; color: #E0E0E0; margin: 0; font-family: 'Inter', sans-serif;">

    <!-- Header / Navigation -->
    <header class="header" id="header">
        <nav class="nav container">
            <a href="../index.html" class="logo">
                <img src="../assets/nefex-logo.png" alt="NEFEX Logo" style="height: 40px; margin-right: 10px;">
                NEFEX
            </a>

            <ul class="nav-links" id="navLinks">
                <li><a href="../whoweare.html">Who We Are</a></li>
                <li><a href="../whatwedo.html">What We Do</a></li>
                <li><a href="../products.html">Products</a></li>
                <li><a href="../blogs.html" class="active" style="color: var(--accent-cyan);">Blogs</a></li>
                <li><a href="../index.html#careers">Careers</a></li>
</ul>

            <button class="menu-toggle" id="menuToggle" aria-label="Toggle menu">
                <span></span>
                <span></span>
                <span></span>
            </button>
        </nav>
    </header>

    <!-- Blog Post Content -->
    <section class="section" style="padding-top: 120px; background: var(--bg-dark);">
        <div class="blog-post-container">

            <!-- Blog Header -->
            <div class="blog-header">
                <div class="blog-meta">
                    <span class="blog-category"><i class="fas fa-code"></i> API Design</span>
                    <span class="blog-date"><i class="far fa-calendar"></i> November 15, 2025</span>
                </div>
                <h1 class="blog-title">Modern API Design Patterns</h1>
                <p class="blog-excerpt">
                    The Architect's Guide to modern API strategy - master REST, GraphQL, gRPC, Event-Driven APIs, and
                    build scalable, secure API ecosystems with multi-paradigm approaches.
                </p>
            </div>

            <!-- Podcast Player -->
            <div class="podcast-player">
                <div class="podcast-title">
                    <i class="fas fa-podcast"></i>
                    Listen to this article as a podcast
                </div>
                <audio controls>
                    <source src="../assets/blog/podcasts/Modern_API_Design_Patterns.m4a" type="audio/mp4">
                    Your browser does not support the audio element.
                </audio>
                <p style="color: var(--text-gray); font-size: 0.9rem; margin-top: 12px;">
                    <i class="far fa-clock"></i> Duration: 24 minutes
                </p>
            </div>

            <!-- Blog Content -->
            <article class="blog-content">

                <!-- Introduction -->
                <h2>Introduction: Beyond REST - Redefining Modern API Strategy</h2>

                <p>
                    Modern API strategy has evolved far beyond a singular focus on REST. Today's architects embrace a
                    multi-paradigm approach, selecting the right API style for the specific architectural challenge at
                    hand. This shift is rooted in the "API-first" development model, where APIs are treated as
                    foundational building blocks of software, not as afterthoughts. This model positions APIs as the
                    connective tissue linking ecosystems of technologies and organizations, enabling businesses to
                    innovate, forge partnerships, and unlock new value.
                </p>

                <p>
                    This guide moves through the foundational principles of REST to more advanced paradigms like
                    GraphQL, gRPC, and Event-Driven APIs. It serves as a comprehensive manual for architects and
                    technical leaders on the patterns, principles, and practices that define modern, scalable, and
                    secure API ecosystems.
                </p>

                <!-- API Design Infographic -->
                <div class="blog-image">
                    <img src="../assets/blog/images/api-design-infographic.jpg"
                        alt="The Modern API Landscape: A Quick Guide">
                    <p class="blog-image-caption">The Modern API Landscape: Foundational Concepts and Popular
                        Architectural Styles</p>
                </div>

                <!-- Section 1 -->
                <h2>1. The Foundation: REST and the Richardson Maturity Model</h2>

                <p>REST remains the bedrock of modern API design, providing a set of constraints and principles that
                    have guided web service development for years.</p>

                <h3>1.1. Core Principles of RESTful Design</h3>
                <p>A well-designed RESTful web API adheres to a set of core principles:</p>

                <ul>
                    <li><strong>Resources:</strong> Design is centered around business entities, or resources, which are
                        identified by unique URIs. These URIs should be based on nouns (e.g., /orders/123), not verbs.
                    </li>
                    <li><strong>Uniform Interface:</strong> Clients interact with resources using a standard set of
                        operations through standard HTTP verbs like GET (retrieve), POST (create), PUT (update/replace),
                        PATCH (partial update), and DELETE (remove).</li>
                    <li><strong>Statelessness:</strong> Every request from a client to the server must contain all the
                        information needed to understand and complete the request. The server does not store any client
                        state between requests.</li>
                    <li><strong>Resource Representations:</strong> Resources are decoupled from their representation. A
                        client can request a resource in a specific format, such as JSON or XML.</li>
                </ul>

                <h3>1.2. The Richardson Maturity Model (RMM)</h3>
                <p>
                    Introduced by Leonard Richardson and popularized by Martin Fowler, the Richardson Maturity Model
                    provides a framework for understanding the different levels of adherence to REST principles. It
                    outlines four levels of maturity:
                </p>

                <ol>
                    <li><strong>Level 0: The Swamp of POX (Plain Old XML)</strong> - Uses HTTP purely as a transport
                        protocol for remote procedure calls (RPC). Typically a single service endpoint URI with all
                        operations via POST requests.</li>

                    <li><strong>Level 1: Resources</strong> - Introduces the concept of distinct resources. Instead of a
                        single service endpoint, the API exposes multiple URIs, each representing a specific business
                        entity or resource.</li>

                    <li><strong>Level 2: HTTP Verbs</strong> - Utilizes the full uniform interface of HTTP. Uses
                        standard HTTP verbs for operations and leverages HTTP status codes to communicate outcomes
                        (e.g., 201 Created for success, 409 Conflict for an error).</li>

                    <li><strong>Level 3: Hypermedia Controls (HATEOAS)</strong> - The highest level of maturity.
                        Resource representations include links that guide the client on what actions can be taken next.
                        This allows a client to navigate the API without prior knowledge of the URI schema, decoupling
                        the client from the server's URI structure.</li>
                </ol>

                <h3>1.3. Specification-Driven Development with OpenAPI</h3>
                <p>
                    The OpenAPI Specification (OAS) is a standard, programming language-agnostic interface description
                    for HTTP APIs. As a Linux Foundation project, it provides a formal standard that allows both humans
                    and computers to understand an API's capabilities without access to source code. An OAS document
                    enables a contract-first approach, where the API definition is used to generate documentation,
                    client and server code, and automated tests.
                </p>

                <!-- Section 2 -->
                <h2>2. Advanced Paradigms: Choosing the Right Tool for the Job</h2>

                <p>While REST is a powerful foundation, modern architectures require a diverse toolkit. Different API
                    styles have emerged to solve specific challenges that REST is not always optimized for.</p>

                <h3>2.1. GraphQL: Flexible Queries for Complex Data</h3>
                <p>
                    GraphQL is a query language for APIs that gives clients the power to ask for exactly the data they
                    need, and nothing more. This solves the common REST problem of over-fetching and under-fetching.
                </p>

                <ul>
                    <li><strong>Schema-Centric Design:</strong> A GraphQL API is defined by a strongly-typed schema that
                        acts as a contract between the client and server.</li>
                    <li><strong>Queries and Mutations:</strong> The API is structured around Queries (for fetching data)
                        and Mutations (for writing or modifying data).</li>
                    <li><strong>Supergraph Architecture:</strong> Composes multiple backend GraphQL services (subgraphs)
                        into a single, unified graph for federated API development.</li>
                    <li><strong>Connectors and Resolvers:</strong> Resolvers contain the logic to fetch data for a
                        field, while connectors provide a declarative pattern for orchestrating calls to backend data
                        sources.</li>
                </ul>

                <h3>2.2. gRPC: High-Performance Binary RPC</h3>
                <p>
                    gRPC is a high-performance, open-source Remote Procedure Call (RPC) framework that allows a client
                    application to directly call methods on a server on a different machine as if it were a local
                    object.
                </p>

                <ul>
                    <li><strong>Protocol Buffers (Protobuf):</strong> Uses Protocol Buffers as its Interface Definition
                        Language (IDL) for serializing structured data.</li>
                    <li><strong>Binary Protocol:</strong> Serializes structured data into a compact binary format,
                        making it significantly faster than text-based protocols like JSON.</li>
                    <li><strong>HTTP/2 Foundation:</strong> Built on HTTP/2, leveraging features like multiplexing and
                        bidirectional streaming.</li>
                    <li><strong>Real-World Use:</strong> Companies like Netflix have adopted gRPC for optimizing
                        communication within their microservice architecture.</li>
                </ul>

                <h3>2.3. Event-Driven APIs: Asynchronous and Real-Time Communication</h3>
                <p>
                    Contrasting with the synchronous request-response model, event-driven architectures enable
                    asynchronous communication, ideal for decoupling services and handling real-time notifications.
                </p>

                <ul>
                    <li><strong>Publish/Subscribe (Pub-Sub):</strong> Services (publishers) send messages to a topic on
                        a lightweight message bus without knowing who the receivers (subscribers) are, creating a highly
                        decoupled system.</li>
                    <li><strong>AsyncAPI Specification:</strong> Provides a standard for defining asynchronous,
                        event-driven APIs, serving a similar role as OpenAPI does for REST.</li>
                </ul>

                <!-- Section 3 -->
                <h2>3. Architectural Patterns in a Distributed World</h2>

                <p>APIs are a critical part of broader system architectures, particularly in distributed environments
                    like microservices.</p>

                <h3>3.1. Microservices Communication Patterns</h3>
                <p>In a microservice architecture, communication between services is paramount:</p>

                <ul>
                    <li><strong>Synchronous Communication:</strong> Request-response pattern where the client blocks
                        until it receives a response. REST and gRPC are common protocols. While simple, it introduces
                        temporal coupling.</li>

                    <li><strong>Asynchronous Communication:</strong> Uses messaging or events where a service sends a
                        message without waiting for an immediate reply. Promotes "smart endpoints and dumb pipes,"
                        improving resilience and decoupling.</li>
                </ul>

                <p>
                    An architect's choice between REST/gRPC (synchronous) and event-driven APIs (asynchronous) directly
                    reflects their strategy for managing temporal coupling and system resilience.
                </p>

                <h3>3.2. API Gateway Patterns</h3>
                <p>An API Gateway acts as a single "front door" for client applications to access data and functionality
                    from backend services:</p>

                <ul>
                    <li><strong>Request Routing:</strong> Directs incoming API calls to the appropriate backend
                        microservice.</li>
                    <li><strong>API Composition/Aggregation:</strong> Combines results from multiple internal services
                        into a single, unified response.</li>
                    <li><strong>Protocol Translation:</strong> Exposes a consistent API style (like REST or GraphQL) to
                        external clients while communicating with internal microservices using different protocols (like
                        gRPC).</li>
                    <li><strong>Cross-Cutting Concerns:</strong> Offloads common responsibilities like authentication,
                        access control, rate limiting, monitoring, and caching.</li>
                    <li><strong>Backend for Frontend (BFF):</strong> Provides a tailored API for specific client
                        experiences (e.g., mobile vs. web).</li>
                </ul>

                <h3>3.3. API Lifecycle Management and Governance</h3>
                <p>
                    API governance is the practice of applying consistent policies, standards, and processes to guide
                    how APIs are designed, built, published, and maintained.
                </p>

                <ol>
                    <li><strong>Take Inventory:</strong> Gain a complete view of the organization's API landscape.</li>
                    <li><strong>Define Policies:</strong> Establish consistent standards for API design, security
                        protocols, and versioning strategies.</li>
                    <li><strong>Enable Teams:</strong> Foster a governance-oriented culture through advocacy, training,
                        and support.</li>
                    <li><strong>Automate Checks:</strong> Augment manual reviews with automated governance checks within
                        the CI/CD pipeline.</li>
                </ol>

                <!-- Section 4 -->
                <h2>4. Essential API Design and Implementation Patterns</h2>

                <p>These practical patterns apply across most API styles and are crucial for building robust,
                    user-friendly APIs.</p>

                <h3>4.1. Versioning Strategies</h3>
                <p>Versioning is necessary to evolve an API over time without breaking existing client applications:</p>

                <table class="comparison-table">
                    <tr>
                        <th>Strategy</th>
                        <th>Description</th>
                        <th>Example</th>
                    </tr>
                    <tr>
                        <td><strong>URI Versioning</strong></td>
                        <td>Version number included directly in the URI path</td>
                        <td>https://api.contoso.com/v2/customers/3</td>
                    </tr>
                    <tr>
                        <td><strong>Query String Versioning</strong></td>
                        <td>Version specified as a query parameter</td>
                        <td>https://api.contoso.com/customers/3?version=2</td>
                    </tr>
                    <tr>
                        <td><strong>Custom Header Versioning</strong></td>
                        <td>Version requested using a custom HTTP header</td>
                        <td>Custom-Header: api-version=2</td>
                    </tr>
                    <tr>
                        <td><strong>Media Type Versioning</strong></td>
                        <td>Version included in Accept header with custom media type</td>
                        <td>Accept: application/vnd.contoso.v1+json</td>
                    </tr>
                </table>

                <h3>4.2. Data Handling: Pagination, Filtering, and Sorting</h3>
                <p>When dealing with large datasets, it's critical to provide clients with data management mechanisms:
                </p>

                <ul>
                    <li><strong>Pagination:</strong> Return large collections in smaller chunks using limit and offset
                        query parameters (e.g., /orders?limit=25&offset=50).</li>
                    <li><strong>Filtering:</strong> Allow clients to refine results by applying conditions via query
                        parameters (e.g., ?status=shipped).</li>
                    <li><strong>Sorting:</strong> Enable clients to order returned data by a specific field (e.g.,
                        ?sort=price).</li>
                </ul>

                <h3>4.3. Ensuring Reliability: Idempotency and Error Handling</h3>
                <ul>
                    <li><strong>Idempotency:</strong> Making the same request multiple times produces the same result as
                        making it once. Critical for safely retrying failed requests. PUT and DELETE verbs must be
                        implemented to be idempotent.</li>
                    <li><strong>Error Handling:</strong> Use standard HTTP status codes (4xx for client errors, 5xx for
                        server errors) and return structured, machine-readable error messages.</li>
                </ul>

                <!-- Section 5 -->
                <h2>5. Security and Operations</h2>

                <p>Non-functional requirements are just as important as the API's features. A production-ready API must
                    be secure, performant, and observable.</p>

                <h3>5.1. Authentication and Authorization</h3>
                <p>Common security schemes include:</p>

                <ul>
                    <li><strong>API Keys:</strong> A secret token passed in a request header, query parameter, or
                        cookie.</li>
                    <li><strong>HTTP Authentication:</strong> Standard schemes like Basic or Bearer tokens.</li>
                    <li><strong>OAuth 2.0:</strong> Industry-standard framework for delegated authorization with flows
                        like Authorization Code and Client Credentials.</li>
                    <li><strong>JSON Web Tokens (JWT):</strong> Compact, self-contained format for bearer tokens.</li>
                    <li><strong>Mutual TLS (mTLS):</strong> Strong authentication where both client and server present
                        and validate SSL certificates.</li>
                </ul>

                <h3>5.2. API Security Fundamentals</h3>
                <ul>
                    <li>The <strong>OWASP API Security Top 10</strong> is a critical awareness document outlining the
                        most common security vulnerabilities in APIs.</li>
                    <li>Adopting a <strong>"Zero Trust"</strong> mindset is a core principle for securing modern
                        software supply chains.</li>
                </ul>

                <h3>5.3. Performance and Caching</h3>
                <p>Caching is a key strategy for improving API performance:</p>

                <ul>
                    <li>In HTTP, <strong>GET requests are cacheable by design</strong>. Proxies and clients can cache
                        responses to avoid redundant calls.</li>
                    <li>The <strong>HEAD request method</strong> retrieves resource headers without fetching the entire
                        response body, allowing clients to determine if cached copies are still valid.</li>
                </ul>

                <h3>5.4. API Observability</h3>
                <p>The three pillars of observability for APIs:</p>

                <ul>
                    <li><strong>Logging:</strong> Recording detailed, time-stamped events and errors for debugging
                        specific issues.</li>
                    <li><strong>Metrics:</strong> Aggregating numerical data about API usage and performance over time
                        (request rates, latency, error rates).</li>
                    <li><strong>Tracing:</strong> Tracking a single request as it propagates through a distributed
                        system of multiple microservices.</li>
                </ul>

                <!-- Section 6 -->
                <h2>6. Patterns in Practice: Real-World Case Studies</h2>

                <p>Leading technology companies provide excellent examples of how these API patterns are applied:</p>

                <ul>
                    <li><strong>Stripe:</strong> A quintessential API-first company. Their engineering culture
                        emphasizes reliability and they are pioneering new standards like the Agentic Commerce Protocol
                        (ACP) in collaboration with OpenAI.</li>

                    <li><strong>Twilio:</strong> Twilio's APIs are organized around REST principles to provide
                        foundational communication building blocks for messaging and voice calls.</li>

                    <li><strong>GitHub:</strong> A prime example of multi-paradigm API strategy, offering both a
                        comprehensive REST API and a flexible GraphQL API.</li>

                    <li><strong>Netflix:</strong> As a pioneer of microservice architecture at scale, Netflix leverages
                        gRPC for highly efficient internal communication between their vast network of microservices.
                    </li>
                </ul>

                <!-- Section 7 -->
                <h2>7. The Future of APIs: AI, Automation, and Intelligence</h2>

                <p>The API landscape is continually evolving, with AI and automation driving the next wave of
                    innovation:</p>

                <ul>
                    <li><strong>AI-Driven and Agentic APIs:</strong> Designing APIs for consumption by AI agents and
                        Large Language Models (LLMs), leading to concepts like the "AI Gateway" and new standards like
                        the "Agentic Commerce Protocol."</li>

                    <li><strong>Connecting AI to APIs:</strong> New platforms like the Apollo MCP Server are emerging to
                        bridge this gap, enabling AI to interact with the world's data and services securely and
                        efficiently.</li>

                    <li><strong>Declarative and Automated API Management:</strong> Moving towards declarative
                        configurations and automated lifecycle management to manage complexity at scale.</li>
                </ul>

                <!-- Conclusion -->
                <h2>8. Conclusion: Key Takeaways for the Modern Architect</h2>

                <p>A successful API strategy is no longer about choosing one tool, but about mastering many:</p>

                <ul>
                    <li><strong>Embrace a Multi-Paradigm Approach:</strong> Modern API design is about having a
                        strategic toolkit. Choose the best paradigm—REST, GraphQL, gRPC, or event-driven—for the
                        specific problem you are solving.</li>

                    <li><strong>Prioritize Governance, Security, and Observability:</strong> As APIs become the central
                        nervous system of the enterprise, robust governance, zero-trust security, and deep observability
                        are critical.</li>

                    <li><strong>Design for Evolution:</strong> APIs are products with a lifecycle. Plan for change
                        through deliberate versioning, build for resilience with patterns like idempotency, and design
                        for discoverability with hypermedia controls.</li>
                </ul>

                <p>
                    In the modern digital economy, a well-architected API strategy is not just a technical detail—it is
                    a significant and sustainable competitive advantage.
                </p>

            </article>

            <!-- Back to Blogs -->
            <div class="back-to-blogs">
                <a href="../blogs.html" class="btn btn-primary btn-lg">
                    <i class="fas fa-arrow-left"></i> Back to All Blogs
                </a>
            </div>

        </div>
    </section>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3 class="logo" style="font-size: 1.5rem; margin-bottom: 16px;">NEFEX</h3>
                    <p style="color: var(--text-gray); margin-bottom: 20px;">Intelligence Engineered</p>
                    <div style="display: flex; gap: 16px;">
                        <a href="https://www.linkedin.com/company/nefex-technologies/" target="_blank"
                            style="color: var(--text-gray); font-size: 1.5rem; transition: var(--transition-smooth);"
                            onmouseover="this.style.color='var(--accent-cyan)'"
                            onmouseout="this.style.color='var(--text-gray)'">
                            <i class="fab fa-linkedin"></i>
                        </a>
                        <a href="https://www.twitter.com/WixStudio" target="_blank"
                            style="color: var(--text-gray); font-size: 1.5rem; transition: var(--transition-smooth);"
                            onmouseover="this.style.color='var(--accent-cyan)'"
                            onmouseout="this.style.color='var(--text-gray)'">
                            <i class="fab fa-twitter"></i>
                        </a>
                    </div>
                </div>

                <div class="footer-section">
                    <h3>Company</h3>
                    <ul class="footer-links">
                        <li><a href="../whoweare.html">Who We Are</a></li>
                        <li><a href="../whatwedo.html">What We Do</a></li>
                        <li><a href="../blogs.html" style="color: var(--accent-cyan);">Blogs</a></li>
                        <li><a href="../index.html#careers">Careers</a></li>
                    </ul>
                </div>

                <div class="footer-section">
                    <h3>Products</h3>
                    <ul class="footer-links">
                        <li><a href="../products.html">FrostBI</a></li>
                        <li><a href="../products.html">IceCube</a></li>
                    </ul>
                </div>

                <div class="footer-section">
                    <h3>Connect</h3>
                    <ul class="footer-links">
                        <li><a href="mailto:Info@nefex.com">Info@nefex.com</a></li>
                        <li><a href="tel:+917405220498">+91 7405220498</a></li>
                        <li><a href="../index.html#contact">Get in Touch</a></li>
                    </ul>
                </div>
            </div>

            <div class="footer-bottom">
                <p>© 2025 NEFEX Technologies. All rights reserved. | Intelligence Engineered</p>
            </div>
        </div>
    </footer>

    <!-- Scripts Disabled to prevent content disappearing -->
    <!-- <script src="../js/main.js"></script> -->
</body>

</html>